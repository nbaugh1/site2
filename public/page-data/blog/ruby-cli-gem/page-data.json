{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/blog/ruby-cli-gem/","result":{"data":{"site":{"siteMetadata":{"title":"Nick Baughman, Software Developer","social":[{"name":"Twitter","url":"https://twitter.com/nbaugh1"},{"name":"GitHub","url":"https://github.com/nbaugh1"}]}},"blogPost":{"id":"9b3878c0-1bdd-5fce-873c-11ebf0dd221d","excerpt":"For our first end of portfolio project we have been assigned to create a Ruby CLI Data Gem. \nI wanted the subject matter of my project to be…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Project 1: Ruby CLI Gem\",\n  \"date\": \"2019-07-12T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For our first end of portfolio project we have been assigned to create a Ruby CLI Data Gem.\\nI wanted the subject matter of my project to be somewhat original and to be something that I find interesting and useful. Being the political junkie that I am, I immediately thought of the huge field of Democratic candidates running for president in the 2020 election. I decided it would be useful to write an app that presents the user with information about the individual candidate\\u2019s campaigns.\"), mdx(\"p\", null, \"Since this project requires that we scrape data from a web page, I set out to find a web page that displays this information in a condensed and concise format. It didn\\u2019t take me too long to land on Ballotpedia.org as my data source. This page provided an easy to navigate list of candidates, each hyperlinked to a seperate profile page with relavent details about the candidate\\u2019s campaign.\"), mdx(\"p\", null, \"From here I had to decide what information I wanted to show the user and how to scrape it from the web pages. Based on the information provided on the profile pages I decided that a quote from the candidate explaining why they are running, a more detailed summary of their campaign platform and experience, and a handful of recent news blurbs about the candidate would be appropriate.\"), mdx(\"p\", null, \"First I set out to build my Scraper Class and methods. I decided I needed one to first build my Candidate instances. I decided that I should iterate through the list of candidates and build instances of a Candidate object with a name and a profile URL slug (to be used by a second method to scrape their profile page). I did so by using Nokogiri and Open-URI with the following code:\"), mdx(\"p\", null, \"BASE_URL = \\u201D\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://ballotpedia.org\"\n  }), \"https://ballotpedia.org\"), \"\\u201D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"def self.name_list_page\\n    Nokogiri::HTML(open(\\\"#{BASE_URL}/Democratic_presidential_nomination,_2020\\\"))\\nend\\n\\ndef self.scrape_names_and_profile_pages\\n    name_list_page.css(\\\"div.mobile-columns ul li b a\\\").each do |candidate|\\n        Dems2020::Candidate.new(candidate.text, candidate.attribute('href').value)\\n    end\\nend\\n\")), mdx(\"p\", null, \"At the outset of building the project I stored this data in an array of hashes, because I felt that my biggest first obstacle would be figuring out which CSS selectors I would need to use and how to iterate through them to properly scrape and store them. Later on I refactored my code use Objects for this instead. To scrape the data from the individual profile pages I used this method:\"), mdx(\"p\", null, \"def self.add_campaign_info\\nDems2020::Candidate.all.each do |candidate|\\ncandidate_info_page = Nokogiri::HTML(open(\\u201D#{BASE_URL}#{candidate.info_page_url}\\u201D))\\ncandidate.quote = candidate_info_page.css(\\u201Ctd\\u201D)\", \"[3]\", \".text\\ncandidate.summary = candidate_info_page.css(\\u201Cp\\u201D)\", \"[9..11]\", \".text\\ncandidate.news1 = candidate_info_page.css(\\u201Cli.panel ul\\u201D)\", \"[0]\", \".text\\ncandidate.news2 = candidate_info_page.css(\\u201Cli.panel ul\\u201D)\", \"[1]\", \".text\\ncandidate.news3 = candidate_info_page.css(\\u201Cli.panel ul\\u201D)\", \"[2]\", \".text\\nend\\nend\\nHere I iterate through an array containing all of my Candidate instances and add a short quote, a campaign summary and 3 recent news headlines. One item on my TODO list is to try and refactor this code in such a way that the data is written to each candidate instance by a Candidate class method rather than by the scraper itself. Also I think that the news headlines can be stored in a better way such as in an array or maybe as objects themselves. Another TODO item.\"), mdx(\"p\", null, \"The code for my Candidate class object is pretty short currently. It contains an initialize method, a method called find_by_index which is used by the CLI object to find a particular Candidate instance within the array of all candidates based on the user selection, and a method called all to access that array.\"), mdx(\"p\", null, \"class Dems2020::Candidate\\nattr_accessor :name, :info_page_url, :quote, :summary, :news1, :news2, :news3\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"@@all = []\\n\\ndef initialize (name = nil, info_page_url = nil, quote = nil, summary = nil, news1 = nil, news2 = nil, news3 = nil)\\n    @@all << self\\n    @name = name\\n    @info_page_url = info_page_url\\n    @quote = quote\\n    @summary = summary\\n    @news1 = news1\\n    @news2 = news2\\n    @news3 = news3\\nend\\n\\ndef self.all\\n    @@all\\nend\\n\\ndef self.find_by_index(input_number)\\n    Dems2020::Candidate.all[input_number - 1]\\nend\\n\")), mdx(\"p\", null, \"end\"), mdx(\"p\", null, \"Lastly I needed to build a CLI object. This is where I present the user with a list of candidates, ask them to make a selection, and then show the the information about the selected candidate. There were a lot of different ways that I thought about doing this in different formats and with various levels of interactivity, but because I\\u2019m working on a tight schedule since I also work full-time, I decided the best way would be the most simple and straight-forward way would be to show all of the information after the user makes a selection. I plan on doing plenty of refactoring later but I\\u2019m currently satisfied with having the app just meet the requirement of going one level deep.\"), mdx(\"p\", null, \"Initially I wrote one giant block of code that formatted and displayed the information in the way that I wanted. I\\u2019ve sense broken it up into methods in order to make DRY. This is still a work in progress. Things on my TODO list include making sure that the user input is valid and presenting them with a message telling them to try again. Currently the app errors out if the input is a number outside of the possible range of options, and also does not deal with non-integer inputs correctly. This is the code for my CLI class (still needs to work):\"), mdx(\"p\", null, \"class Dems2020::Cli\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"@@selected_candidate = nil\\n\\ndef self.list_candidates\\n    Dems2020::Candidate.all.each_with_index do |candidate, index|\\n        puts \\\"#{index + 1}. #{candidate.name}\\\"\\n        \\n    end\\nend\\n\\ndef self.start\\n    system 'clear'\\n    puts \\\"\\\"\\n    puts \\\"\\\"\\n    puts \\\"2020 DEMOCRATIC CANDIDATES FOR PRESIDENT\\\"\\n    puts \\\"\\\"\\n    puts \\\"========================================\\\"\\n    Dems2020::Cli.list_candidates\\n    puts \\\"========================================\\\"\\n    puts \\\"\\\"\\n    puts \\\"Please enter the number of the candidate which you like to learn more about: \\\"\\n    get_candidate\\n    print_candidate_info\\n    list_or_exit\\nend\\n\\ndef self.get_candidate\\n    input_number = gets.to_i \\n    @@selected_candidate = Dems2020::Candidate.find_by_index(input_number)\\nend\\n\\ndef self.list_or_exit\\n    puts \\\"\\\"\\n    puts \\\"================================================================\\\"\\n    puts \\\"\\\"\\n    puts \\\"To return to the candidate list enter 'list'\\\"\\n    puts \\\"To exit enter 'exit'\\\"\\n    input = gets.strip\\n    if input == 'list'\\n        start\\n    elsif input == 'exit'\\n        puts \\\"Thanks! Goodbye\\\"\\n    else\\n        puts \\\"Sorry, I didn't understand that\\\"\\n        list_or_exit\\n    end\\nend\\n\\ndef self.print_candidate_info\\n    system 'clear'\\n    puts \\\"\\\"\\n    puts \\\"\\\"\\n    puts \\\"You have chosen to learn more about -#{@@selected_candidate.name}-\\\"\\n    puts \\\"================================================================\\\"\\n    puts \\\"\\\"\\n    puts \\\"#{@@selected_candidate.name}'s reason for running for president in 2020:\\\"\\n    puts \\\"\\\"\\n    puts \\\"'#{@@selected_candidate.quote}' -#{@@selected_candidate.name}\\\"\\n    puts \\\"\\\"\\n    puts \\\"================================================================\\\"\\n    puts \\\"\\\"\\n    puts \\\"Summary of #{@@selected_candidate.name}'s campaign platform and experience:\\\"\\n    puts \\\"\\\"\\n    puts @@selected_candidate.summary\\n    puts \\\"\\\"\\n    puts \\\"================================================================\\\"\\n    puts \\\"\\\"\\n    puts \\\"Recent news about #{@@selected_candidate.name}:\\\"\\n    puts \\\"\\\"\\n    puts @@selected_candidate.news1\\n    puts \\\"\\\"\\n    puts @@selected_candidate.news2\\n    puts \\\"\\\"\\n    puts @@selected_candidate.news3\\nend\\n\")), mdx(\"p\", null, \"end\"), mdx(\"p\", null, \"There are also still a couple of things I\\u2019d like to do like removing citation markers form the text and also removing a couple of bugs due to inconsistent formatting on the web pages, as well as making everything a bit prettier in the CLI, but right now this is what the app looks like when run:\"), mdx(\"p\", null, \"Warren 2020!\\nOne downside to this project is that it will seem less and less useful as time goes on and people drop out of the race, but for now it works for my assignment. The code should also be easily refactored to be applied to other elections, as long as ballotpedia doesn\\u2019t change things up too much.\"), mdx(\"p\", null, \"UPDATE 7/13/19: I went ahead and moved some methods out of my sScraper class and into the Candidate class. Now all that the Scraper class does is scrape data rather than scrape data AND build candidate objects. I also refactored a bit and now rather than building all of the Candidate objects and adding their information upon running the app, only the basic Candidate objects with names and URLs are built and put into an array. The extra candidate info is scraped and added to the object instance after the user selects which candidate they\\u2019d like to read about. This has greatly decreased the amount of time it takes for the app to load since it only has to scrape data from one page upon running, rather than 24 separate pages.\"), mdx(\"p\", null, \"github >> \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/nbaugh1/candidates-app\"\n  }), \"https://github.com/nbaugh1/candidates-app\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/blog/ruby-cli-gem/","title":"Project 1: Ruby CLI Gem","tags":[],"keywords":[],"date":"July 12, 2019"},"previous":{"id":"78410de0-4d85-5c38-b2e2-5327da74f35e","excerpt":"So I've got basically one month completed in the Flatiron School Software Engineering Online Full-time program. I'm heading into my first…","slug":"/blog/one-month-in/","title":"One Month In","date":"July 01, 2019"},"next":{"id":"d55ba5a5-f2cf-58fb-bcf0-bb8a6c736369","excerpt":"For my Sinatra module portfolio project I decided to make an app to build a fantasy football team roster. The requirements for this project…","slug":"/blog/sinatra-CRUD-MVC/","title":"Project 2: Sinatra CRUD MVC","date":"August 12, 2019"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9b3878c0-1bdd-5fce-873c-11ebf0dd221d","previousId":"78410de0-4d85-5c38-b2e2-5327da74f35e","nextId":"d55ba5a5-f2cf-58fb-bcf0-bb8a6c736369"}}}